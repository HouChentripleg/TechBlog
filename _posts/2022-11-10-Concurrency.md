---
title: ConcurrencyBasics(Atomic, memory order)
author: Hou Chen
date: 2022-11-10 11:10:00 +0800
categories: [C++, Concurrency, Basics]
tags: [c++, concurrency, basics]
---

# ä»£ç æ‰§è¡Œé¡ºåº
- å…³äºä»£ç çš„æ‰§è¡Œé¡ºåºï¼Œå…ˆçœ‹ä¸€ä¸ªğŸŒ°

```c++
// å…¨å±€å˜é‡
int x = 0;
int y = 0;

// çº¿ç¨‹A
x = 1;
y = 2;

// çº¿ç¨‹B
if(y == 2) {
    x = 3;
    y = 4;
}
```

- ä¸Šé¢è¿™æ®µä»£ç çš„æ‰§è¡Œç»“æœæœ‰è¿™æ ·å‡ ç§å¯èƒ½ï¼š
    - x = 1, y = 2
    - x = 3, y = 4
    - x = 1, y = 4
- ç»“æœ1å’Œ2æ˜¯å¾ˆè‡ªç„¶çš„ï¼Œä½†æ˜¯xå’Œyåœ¨ä¸¤ä¸ªå¹¶è¡Œçš„çº¿ç¨‹ä¸­è¢«è¯»å†™ï¼Œå‡ºç°äº†data raceï¼Œä¸”ç¼–è¯‘å™¨æŒ‡ä»¤reorderå’ŒCPUä¹±åºæ‰§è¡Œä¹Ÿå¯èƒ½ä¼šé€ æˆç»“æœ3
    - ç¼–è¯‘å™¨ï¼šåœ¨æ»¡è¶³ç¨‹åºâ€œå¯è§‚æµ‹â€å¤–éƒ¨è¡Œä¸ºçš„ä¸€è‡´æ€§æ—¶(å¤§ç™½è¯å°±æ˜¯å¤–éƒ¨çœ‹åˆ°çš„æ¯ä¸€æ¬¡ä¿®æ”¹é¡ºåºæ˜¯ä¸€æ ·çš„ï¼Œå°½ç®¡ä¸åŒè½®çš„è¿è¡Œé¡ºåºå¯èƒ½ä¸ä¸€æ ·)ï¼Œç¼–è¯‘å™¨æ ¹æ®ä¸Šä¸‹æ–‡è°ƒæ•´ä»£ç çš„æ‰§è¡Œé¡ºåºï¼Œä½¿å…¶æœ€æœ‰åˆ©äºCPUæ¶æ„ï¼Œæ­¤å³**ç¼–è¯‘å™¨ä¼˜åŒ–**ã€‚å¯¹äºå•ä¸ªçº¿ç¨‹è€Œè¨€ï¼Œå…ˆæ‰§è¡Œx = 1è¿˜æ˜¯y = 2å®Œå…¨æ— å…³ç´§è¦ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰å¤–éƒ¨â€œå¯è§‚æµ‹â€çš„åŒºåˆ«ï¼Œä½†å¯¹äºå¤šçº¿ç¨‹å°±æœ‰å¾ˆå¤§çš„åŒºåˆ«äº†
    - å¤„ç†å™¨ï¼šCPUä¹Ÿä¼šå¯¹ä»£ç çš„æ‰§è¡Œé¡ºåºè¿›è¡Œè°ƒæ•´ï¼Œæ­¤å³**CPUä¹±åºæ‰§è¡Œ**ã€‚åœ¨å¤šå¤„ç†å™¨æ¶æ„ä¸­ï¼Œå„ä¸ªCPUå¯èƒ½å­˜åœ¨ç¼“å­˜ä¸ä¸€è‡´çš„é—®é¢˜(æ¯ä¸ªCPUå¯¹è‡ªå·±çš„ç¼“å­˜çš„å†™æ“ä½œåœ¨å„ä¸ªCPUåŒæ­¥ä¹‹å‰ä¼šé€ æˆä¸»å­˜ä¸­çš„åŒä¸€ä¸ªæ•°æ®åœ¨å„ä¸ªCPUç¼“å­˜ä¸­çš„ä¸ä¸€è‡´)ï¼Œè¿™å–å†³äºCPUç±»å‹ã€ç¼“å­˜ç­–ç•¥å’Œå˜é‡åœ°å€ï¼Œx86ä½¿ç”¨çš„å†…å­˜æ¨¡å‹åŸºæœ¬æä¾›äº†sequential consistencyé¡ºåºä¸€è‡´æ€§ï¼Œè€Œå…¶ä»–æ¶æ„å¦‚ARMå°±åªæä¾›äº†relaxed consistencyæ¾æ•£ä¸€è‡´æ€§

---

# std::atomic

> åœ¨å¼•å…¥åŸå­å¯¹è±¡å‰ï¼Œå¯¹äºå¤šçº¿ç¨‹é—´çš„å†…å­˜åŒæ­¥é—®é¢˜ï¼Œæˆ‘ä»¬æˆ–è®¸ä¼šæƒ³åˆ°volatileï¼Œåœ¨javaå’ŒC#ä¸­å®ƒä¹Ÿçš„ç¡®èƒ½ç”¨æ¥å¤„ç†æŒ‡ä»¤é‡æ’ï¼Œä½†è¿™å¹¶ä¸æ˜¯volatileçš„è®¾è®¡åˆè¡·ï¼Œvolatileç”¨äºé˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–æ‰å¯¹å†…å­˜çš„è¯»å†™ï¼Œé¿å…ç¼–è¯‘å™¨ä¸€ç›´åªè¯»å–è¯¥å˜é‡åœ¨å¯„å­˜å™¨ä¸­çš„å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä¸»è¦ç”¨æ¥è¯»å†™æ˜ å°„åœ¨å†…å­˜åœ°å€ä¸Šçš„I/Oæ“ä½œï¼Œå¹¶ä¸èƒ½ä¿è¯åœ¨å¤šå¤„ç†å™¨ç¯å¢ƒä¸‹å¤šçº¿ç¨‹èƒ½çœ‹åˆ°ç›¸åŒé¡ºåºçš„æ•°æ®å˜åŒ–
{: .prompt-info }

> æ­¤å¤–ï¼Œæˆ‘ä»¬æˆ–è®¸ä¹Ÿä¼šæƒ³åˆ°ä½¿ç”¨std::mutexè§£å†³å¹¶å‘è¯»å†™çš„é—®é¢˜ï¼Œä½†æ˜¯å®ƒæ˜¯æ“ä½œç³»ç»Ÿçº§çš„ï¼Œç¼–è¯‘åæ˜¯ä¸€ç»„cpuæŒ‡ä»¤ï¼Œå¯¹äºå•ä¸ªå˜é‡çš„è¯»å†™è¿‡äºå¤æ‚
{: .prompt-info }

> æ„è¯†åˆ°è¿™äº›åï¼ŒC++11é‡Œç»ˆäºå¼•å…¥äº†é€‚åˆå¤šçº¿ç¨‹çš„å†…å­˜æ¨¡å‹ï¼Œæ­¤å¤„æˆ‘ä»¬é‡ç‚¹å…³æ³¨std::atomicã€åŸå­æ“ä½œã€å†…å­˜åºç­‰
{: .prompt-tip }

## Intro

- C++11åœ¨å¤´æ–‡ä»¶`<atomic>`ä¸­å¼•å…¥çš„æ¨¡æ¿`std::atomic`å¯¹åŸå­å¯¹è±¡è¿›è¡Œäº†å°è£…ï¼Œå°†åŸå­ç±»å‹çš„è¯»å†™æ“ä½œä»ä¸€ç»„æŒ‡ä»¤æœ€å°åŒ–åˆ°å•ä¸ªCPUæŒ‡ä»¤
- è®©æˆ‘ä»¬callbackæœ€åˆçš„é‚£ä¸ªğŸŒ°ï¼Œå¦‚æœå¸Œæœ›åªæœ‰ç»“æœ1å’Œ2ï¼Œéœ€è¦å°†yå£°æ˜ä¸ºåŸå­å˜é‡ï¼Œå¹¶åœ¨x = 1å’Œy = 2ä¹‹é—´åŠ å…¥å†…å­˜å±éšœï¼Œç¦æ­¢è¿™ä¸¤å¥äº¤æ¢é¡ºåºï¼Œåœ¨æ­¤å¸¸ç”¨çš„æ˜¯â€œè·å¾—acquireâ€å’Œâ€œé‡Šæ”¾releaseâ€è¯­ä¹‰
    - **acquire**: å¯¹å†…å­˜çš„**è¯»**æ“ä½œï¼Œå½“å‰çº¿ç¨‹çš„ä»»ä½•**åé¢**çš„è¯»å†™æ“ä½œéƒ½ä¸å…è®¸é‡æ’åˆ°è¿™ä¸ªæ“ä½œçš„**å‰é¢**
    - **release**: å¯¹å†…å­˜çš„**å†™**æ“ä½œï¼Œå½“å‰çº¿ç¨‹çš„ä»»ä½•**å‰é¢**çš„è¯»å†™æ“ä½œéƒ½ä¸å…è®¸é‡æ’åˆ°è¿™ä¸ªæ“ä½œçš„**åé¢**

```c++
// å…¨å±€å˜é‡
int x = 0;
std::atomic<int> y = 0;

// çº¿ç¨‹A
x = 1;
y.store(2, std::memory_order_release);

// çº¿ç¨‹B
if(y.load(std::memory_order_acquire) == 2) {
    x = 3;
    y.store(4, std::memory_order_relaxed);
}
```
- å€Ÿç”¨å´è€å¸ˆçš„å›¾ç¤ºæ„ï¼Œæ¯ä¸€è¾¹çš„ä»£ç éƒ½ä¸å…è®¸é‡æ’è¶Šè¿‡é»„è‰²åŒºåŸŸï¼Œä¸”è‹¥yçš„releaseæ—©äºyçš„acquireï¼Œçº¿ç¨‹Aä¸­releaseä¹‹å‰å¯¹å†…å­˜çš„ä¿®æ”¹åœ¨çº¿ç¨‹Bçš„acquireåéƒ½æ˜¯å¯è§çš„(â€œå¯è§â€è¿™ä¸ªæ¦‚å¿µæˆ‘ä»¬åœ¨åé¢è§£é‡ŠHappens-beforeæ—¶å†è§£é‡Šï¼Œå¤§è‡´ç†è§£èµ·æ¥å°±æ˜¯æ‰§è¡Œacquireå’Œreleaseæ“ä½œçš„ä¸¤ä¸ªçº¿ç¨‹èƒ½è§‚å¯Ÿåˆ°ç›¸åŒçš„å†…å­˜ä¿®æ”¹ç»“æœ)

![acquire/release](/_posts/img/Concurrency/barrier.png){: width="972" height="589" }
_Full screen width and center alignment_

<br>

- ç†è®ºä¸Šï¼Œ`std::atomic<T>`èƒ½å¯¹ä»»æ„ç±»å‹è¿›è¡ŒåŸå­å°è£…ï¼Œå¹¶éæ‰€æœ‰çš„åŸå­ç±»å‹éƒ½èƒ½æœ‰åŸå­æ“ä½œï¼Œè¿™å–å†³äºCPUçš„æ¶æ„ï¼Œä»¥åŠå®ƒæ‰€å®ä¾‹åŒ–çš„ç±»å‹ç»“æ„æ˜¯å¦æ»¡è¶³CPUæ¶æ„å¯¹å†…å­˜å¯¹é½çš„è¦æ±‚ï¼Œä¾‹å¦‚å¯¹äºæ•´å‹å’ŒæŒ‡é’ˆç­‰ç®€å•ç±»å‹ï¼Œé€šå¸¸å°è£…åå°±æ˜¯æ— é”çš„åŸå­å¯¹è±¡ï¼Œä½†å¦å¤–ä¸€äº›ç±»å‹ï¼Œä¾‹å¦‚64-bitæœºå™¨ä¸Šå¤§å°ä¸æ˜¯1, 2, 4, 8çš„ç±»å‹ï¼Œç¼–è¯‘å™¨è¿˜æ˜¯ä¼šä¸ºè¿™äº›åŸå­å¯¹è±¡çš„æ“ä½œåŠ é”ï¼Œå¯ä»¥é€šè¿‡`std::atomic<T>::is_lock_free()`æ£€æŸ¥è¯¥åŸå­ç±»å‹æ˜¯å¦æ— é”(æ˜¯å¦å¯ä»¥ç”¨CPUçš„æŒ‡ä»¤ç›´æ¥å®ŒæˆåŸå­æ“ä½œ)

```c++
#include <iostream>
#include <atomic>

using namespace std;

struct Test {
    float x;
    int y;
    long long z;
};

int main() {
    atomic<Test> t;
    cout << boolalpha << t.is_lock_free() << endl;

    return 0;
}
```

- å½“ç„¶ï¼Œå„ä¸ªç±»å‹çš„åŸå­å°è£…ä¹Ÿæœ‰åˆ«åï¼Œè¯¦ç»†çš„å¯è§cppreference
```c++
typedef std::atomic<int> atomic_int;
typedef std::atomic<long long> actomic_llong;
```

## åŸå­æ“ä½œ

- åŸå­æ“ä½œä¸»è¦æœ‰ä¸‹é¢ä¸‰ç±»ï¼š
    - **store**: åŸå­åœ°å°†ä¸€ä¸ªå€¼å†™å…¥åŸå­å¯¹è±¡ä¸­
    - **load**: åŸå­åœ°è¯»å–åŸå­å¯¹è±¡ä¸­çš„å€¼
    - **Read-Modify-Write**: åŸå­åœ°è¯»å–å†…å­˜ã€ä¿®æ”¹æ•°å€¼ã€å†™å›å†…å­˜ï¼Œæ•´ä¸ªæ“ä½œè¿‡ç¨‹ä¸­ä¸ä¼šæœ‰å…¶ä»–å†™æ“ä½œçš„æ’å…¥

## Happens-before

> Happens-beforeæ˜¯ç†è§£å†…å­˜åºå’Œå†…å­˜æ¨¡å‹çš„ä¸€ä¸ªéå¸¸åŸºç¡€çš„æ¦‚å¿µï¼šå¦‚æœæ“ä½œ1 Happens-beforeæ“ä½œ2ï¼Œåˆ™æ“ä½œ1çš„ç»“æœå¯¹äºæ“ä½œ2å¯è§
{: .prompt-tip }

### å•çº¿ç¨‹: sequenced-before

- å•çº¿ç¨‹çš„æƒ…å†µéå¸¸å¥½ç†è§£ï¼Œä»£ç å°±æ˜¯é¡ºåºæ‰§è¡Œï¼Œæœ‰å‰åé¡ºåºï¼Œé‚£ä¹ˆå‰é¢çš„è¯­å¥æ€»æ˜¯sequenced-beforeåé¢çš„è¯­å¥
- sequenced-beforeå…·æœ‰ä¼ é€’æ€§ï¼šå¦‚æœæ“ä½œ1 sequenced-beforeæ“ä½œ2,æ“ä½œ2 sequenced-beforeæ“ä½œ3ï¼Œé‚£ä¹ˆæ“ä½œ1 sequenced-beforeæ“ä½œ3

### å¤šçº¿ç¨‹: synchronizes-withå’Œinter-thread happens-before

- synchronizes-with: çº¿ç¨‹Aä¸­çš„æ“ä½œ1å’Œçº¿ç¨‹Bä¸­çš„æ“ä½œ2æ˜¯â€œåŒæ­¥â€çš„ï¼Œå³synchronizes-with(ä¹‹åæˆ‘ä»¬å†è§£é‡Šå¦‚ä½•é€šè¿‡å†…å­˜åºå®ç°synchronizes-with)
- å¦‚æœçº¿ç¨‹Aä¸­çš„æ“ä½œ1 synchronizes-withçº¿ç¨‹Bä¸­çš„æ“ä½œ2ï¼Œåˆ™æ“ä½œ1 inter-thread happens-before æ“ä½œ2
- inter-thread happens-beforeä¹Ÿæœ‰ä¼ é€’æ€§ï¼š
    - å¦‚æœçº¿ç¨‹Aä¸­çš„æ“ä½œ1 synchronizes-withçº¿ç¨‹Bä¸­çš„æ“ä½œ2ï¼Œä¸”æ“ä½œ2 sequenced-beforeæ“ä½œ3ï¼Œåˆ™æ“ä½œ1 inter-thread happens-before æ“ä½œ3
    - å¦‚æœçº¿ç¨‹Aä¸­çš„æ“ä½œ1 sequenced-before æ“ä½œ2ï¼Œæ“ä½œ2 inter-thread happens-beforeçº¿ç¨‹Bä¸­çš„æ“ä½œ3ï¼Œé‚£ä¹ˆæ“ä½œ1 inter-thread happens-beforeæ“ä½œ3
    - å¦‚æœçº¿ç¨‹Aä¸­çš„æ“ä½œ1 inter-thread happens-beforeçº¿ç¨‹Bä¸­çš„æ“ä½œ2ï¼Œä¸”æ“ä½œ2 inter-thread happens-beforeçº¿ç¨‹Cçš„æ“ä½œ3ï¼Œåˆ™æ“ä½œ1 inter-thread happens-beforeæ“ä½œ3

![happens-before](/_posts/img/Concurrency/happensbefore.png){: width="972" height="589" }
_Full screen width and center alignment_

<br>

- æ¥ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾æ“ä½œ2 synchronizes-with æ“ä½œ3ï¼Œé‚£ä¹ˆæ“ä½œ1 inter-thread happens-beforeæ“ä½œ4ï¼Œä¹Ÿå³æ“ä½œ1 Happens-beforeæ“ä½œ4ï¼Œæ‰€ä»¥æ“ä½œ4æ€»èƒ½è¯»åˆ°æ“ä½œ1å¯¹açš„ä¿®æ”¹

```c++
void threadA() {
    a += 1;     // 1
    unlock();   // 2
}

void threadB() {
    lock();     // 3
    cout << a << endl;  // 4
}
```
- å€¼çš„æ³¨æ„çš„æ˜¯ï¼ŒHappens-beforeæ˜¯C++è¯­ä¹‰å±‚é¢çš„æ¦‚å¿µï¼Œå¹¶ä¸è¡¨ç¤ºæŒ‡ä»¤åœ¨CPUä¸­å®é™…çš„æ‰§è¡Œé¡ºåº

## å†…å­˜åº

- æ¯ä¸ªåŸå­æ“ä½œéƒ½éœ€è¦æŒ‡å®šä¸€ä¸ª**å†…å­˜åºmemory order**ï¼Œä¸åŒçš„å†…å­˜é¡ºåºä»£è¡¨ä¸åŒçš„è¯­ä¹‰ï¼Œä¹Ÿå¯¹åº”ä¸åŒçš„**é¡ºåºæ¨¡å‹order modal**
    - **memory_order_relaxed**: æ¾æ•£å†…å­˜åºï¼Œåªç”¨äºä¿è¯å¯¹åŸå­å¯¹è±¡çš„æ“ä½œæ˜¯åŸå­çš„ï¼Œå•ä¸ªçº¿ç¨‹å†…çš„åŸå­æ“ä½œéƒ½æ˜¯é¡ºåºæ‰§è¡Œçš„ï¼Œä¸å…è®¸æŒ‡ä»¤é‡æ’ï¼Œä½†ä¸åŒçº¿ç¨‹é—´åŸå­æ“ä½œçš„é¡ºåºæ˜¯ä»»æ„çš„
    - **memory_order_consume**: ä¸æ¨èä½¿ç”¨
    - **memory_order_acquire**: è·å¾—æ“ä½œï¼Œåœ¨è¯»å–è¯¥åŸå­å¯¹è±¡æ—¶ï¼Œå½“å‰çº¿ç¨‹çš„ä»»ä½•åé¢çš„è¯»å†™æ“ä½œéƒ½ä¸å…è®¸é‡æ’åˆ°æ­¤æ“ä½œçš„å‰é¢ï¼Œä¸”å…¶ä»–çº¿ç¨‹å¯¹åŒä¸€ä¸ªåŸå­å¯¹è±¡é‡Šæ”¾å‰çš„æ‰€æœ‰å†…å­˜å†™å…¥éƒ½åœ¨å½“å‰çº¿ç¨‹å¯è§
    - **memory_order_release**: é‡Šæ”¾æ“ä½œï¼Œåœ¨å†™å…¥è¯¥åŸå­å¯¹è±¡æ—¶ï¼Œå½“å‰çº¿ç¨‹çš„ä»»ä½•å‰é¢çš„è¯»å†™æ“ä½œéƒ½ä¸å…è®¸é‡æ’åˆ°æ­¤æ“ä½œçš„åé¢ï¼Œä¸”å½“å‰çº¿ç¨‹çš„æ‰€æœ‰å†…å­˜å†™å…¥éƒ½å¯¹åŒä¸€ä¸ªåŸå­å¯¹è±¡è¿›è¡Œè·å–çš„å…¶ä»–çº¿ç¨‹å¯è§
    - **memory_order_acq_rel**: è·å¾—-é‡Šæ”¾æ“ä½œï¼Œä¸€ä¸ªRead-Modify-Writeæ“ä½œåŒæ—¶å…·æœ‰acquireè¯­ä¹‰å’Œreleaseè¯­ä¹‰ï¼Œå³å®ƒå‰åçš„ä»»ä½•è¯»å†™æ“ä½œéƒ½ä¸å…è®¸é‡æ’ï¼Œä¸”å…¶ä»–çº¿ç¨‹å¯¹åŒä¸€ä¸ªåŸå­å¯¹è±¡é‡Šæ”¾å‰çš„æ‰€æœ‰å†…å­˜å†™å…¥éƒ½åœ¨å½“å‰çº¿ç¨‹å¯è§ï¼Œå½“å‰çº¿ç¨‹çš„æ‰€æœ‰å†…å­˜å†™å…¥éƒ½åœ¨å¯¹åŒä¸€ä¸ªåŸå­å¯¹è±¡è¿›è¡Œè·å–çš„å…¶ä»–çº¿ç¨‹å¯è§
    - **memory_order_seq_cst**: é¡ºåºä¸€è‡´æ€§è¯­ä¹‰ï¼Œæ‰€æœ‰çº¿ç¨‹çœ‹åˆ°çš„æ‰€æœ‰æ“ä½œéƒ½æœ‰ä¸€ä¸ªå…¨å±€ä¸€è‡´çš„é¡ºåºï¼Œå¯¹äºè¯»æ“ä½œç›¸å½“äºacquireï¼Œå¯¹äºå†™æ“ä½œç›¸å½“äºreleaseï¼Œå¯¹äºRead-Modify-Writeæ“ä½œç›¸å½“äºacquire-releaseï¼Œæ˜¯æ‰€æœ‰åŸå­æ“ä½œçš„é»˜è®¤å†…å­˜åºï¼ˆæ­¤å¤–ï¼Œé¡ºåºä¸€è‡´æ€§è¿˜ä¿è¯äº†å¤šåŸå­é‡çš„ä¿®æ”¹åœ¨æ‰€æœ‰çº¿ç¨‹é‡Œè§‚å¯Ÿåˆ°çš„ä¿®æ”¹é¡ºåºéƒ½ç›¸åŒï¼‰

### memory_order_seq_cst

- ä¸‹é¢çš„ä»£ç å„è½®çš„è¿è¡Œç»“æœå¯èƒ½éƒ½ä¸ä¸€æ ·ï¼Œæœ‰å¯èƒ½å…ˆæ‰§è¡Œæ“ä½œ1å†æ‰§è¡Œ2ï¼Œä¹Ÿæœ‰å¯èƒ½å…ˆæ‰§è¡Œæ“ä½œ2å†æ‰§è¡Œæ“ä½œ1ï¼Œä½†æ˜¯æ¯ä¸€è½®ä¸­æ‰€æœ‰çº¿ç¨‹çœ‹åˆ°çš„é¡ºåºéƒ½æ˜¯ä¸€æ ·çš„ï¼Œxå’Œyçš„store()æ“ä½œéƒ½ä½¿ç”¨äº†memory_order_seq_cstï¼Œå¯¹è±¡çš„ä¿®æ”¹æ˜¯é¡ºåºä¸€è‡´çš„ã€‚å‡å¦‚å…ˆæ‰§è¡Œæ“ä½œ1å†æ‰§è¡Œ2ï¼Œé‚£ä¹ˆå½“tDçº¿ç¨‹æ‰§è¡Œæ“ä½œ5é€€å‡ºå¾ªç¯æ—¶ï¼Œå³yä¸ºtrueæ—¶ï¼Œxä¹Ÿå¿…ç„¶åœ¨å®ƒä¹‹å‰å°±ç½®trueäº†ï¼Œå†æ‰§è¡Œ6ï¼Œ++zï¼›å‡å¦‚å…ˆæ‰§è¡Œæ“ä½œ2å†æ‰§è¡Œæ“ä½œ1ï¼Œé‚£ä¹ˆå½“tCçº¿ç¨‹æ‰§è¡Œæ“ä½œ3æ—¶ï¼Œå³xä¸ºtrueæ—¶ï¼Œyå¿…ç„¶åœ¨æ­¤ä¹‹å‰ä¹Ÿè¢«ç½®trueäº†ï¼Œæ‰€ä»¥æ“ä½œ4ä¹Ÿä¼šæ‰§è¡Œã€‚æ‰€ä»¥æ— è®ºæ˜¯å“ªç§æ‰§è¡Œé¡ºåºï¼Œæ“ä½œ7çš„æ–­è¨€æ°¸è¿œä¸ä¼šé€€å‡º

```c++
#include <iostream>
#include <atomic>
#include <thread>
#include <assert.h>

using namespace std;

atomic<bool> x(false), y(false);
atomic<int> z(0);

void threadA() {
    x.store(true, memory_order_seq_cst);    // 1
}

void threadB() {
    y.store(true, memory_order_seq_cst);    // 2
}

void x_then_y() {
    while(!x.load(memory_order_seq_cst));   // 3
    if(y.load(memory_order_seq_cst)) ++z;   // 4
}

void y_then_x() {
    while(!y.load(memory_order_seq_cst));   // 5
    if(x.load(memory_order_seq_cst)) ++z;   // 6
}

int main() {
    thread tA(threadA), tB(threadB), tC(x_then_y), tD(y_then_x);

    tA.join();
    tB.join();
    tC.join();
    tD.join();

    assert(z.load() != 0);  // 7

    return 0;
}
```

- é¡ºåºä¸€è‡´æ€§è¯­ä¹‰å¯ä»¥å®ç°synchronizes-withçš„å…³ç³»ï¼šå¦‚æœä¸€ä¸ªmemory_order_seq_cstçš„load()æ“ä½œè¯»åˆ°äº†åœ¨è¿™ä¸ªåŸå­å¯¹è±¡ä¸­ç”±memory_order_seq_cstçš„store()æ“ä½œå†™å…¥çš„å€¼ï¼Œé‚£ä¹ˆmemory_order_seq_cstçš„store()æ“ä½œsynchronizes-with memory_order_seq_cstçš„load()æ“ä½œï¼Œåæ˜ åˆ°ä¸Šé¢çš„ä»£ç ä¸­å°±æ˜¯ï¼š1 synchronizes-with 3, 2 synchronizes-with 5
- ä½†æ˜¯è¦æ³¨æ„ï¼Œå®ç°é¡ºåºä¸€è‡´æ€§çš„å¼€é”€æ¯”è¾ƒå¤§ï¼Œå› ä¸ºè¦ä¿è¯å¤šæ ¸CPUçš„ç¼“å­˜ä¸€è‡´

### memory_order_relaxed

- memory_order_relaxedçš„å¼€é”€éå¸¸å°ï¼Œä½†æ˜¯å®ƒåªä¿è¯äº†store, load, Read-Modify-Writeæ“ä½œçš„åŸå­æ€§ï¼Œä¸èƒ½å®ç°synchronizes-with
- ä¿®æ”¹ä¸€ä¸‹å†…å­˜åºï¼Œå†æ¥çœ‹ä¸€æ®µä»£ç ï¼šçº¿ç¨‹Aå¯¹x, yè¿™ä¸¤ä¸ªåŸå­å¯¹è±¡æ‰§è¡Œstore()æ“ä½œï¼Œä½¿ç”¨memory_order_relaxedï¼Œåœ¨åŒä¸€è½®è¿è¡Œä¸­ï¼Œåœ¨æŸäº›çº¿ç¨‹çœ‹æ¥å¯èƒ½æ˜¯å…ˆæ‰§è¡Œ1å†æ‰§è¡Œ2ï¼Œå¦ä¸€äº›çº¿ç¨‹çœ‹æ¥å´æ˜¯å…ˆæ‰§è¡Œ2å†æ‰§è¡Œ1ï¼Œæ‰€ä»¥4å¤„çš„æ–­è¨€å°±å¯èƒ½å¤±è´¥ï¼Œå› ä¸º2å’Œ3æ²¡æœ‰synchronizes-withçš„å…³ç³»ï¼Œä¸èƒ½ä¿è¯æ“ä½œ1 Happens-before æ“ä½œ2

```c++
#include <iostream>
#include <atomic>
#include <thread>
#include <assert.h>

using namespace std;

atomic<bool> x(false), y(false);

void threadA() {
    x.store(true, memory_order_relaxed);    // 1
    y.store(true, memory_order_relaxed);    // 2
}

void threadB() {
    while(!y.load(memory_order_relaxed));   // 3
    assert(x.load());  // 4
}

int main() {
    thread tA(threadA), tB(threadB);

    tA.join();
    tB.join();

    return 0;
}
```

- memory_order_relaxedå¯ä»¥ç”¨åœ¨ä¸éœ€è¦çº¿ç¨‹åŒæ­¥çš„åœºæ™¯ï¼Œæ¯”å¦‚shared_ptrå¢åŠ å¼•ç”¨è®¡æ•°æ—¶å°±ç”¨çš„memory_order_relaxedï¼Œå› ä¸ºä¸éœ€è¦åŒæ­¥ï¼Œä½†å‡å°‘å¼•ç”¨è®¡æ•°çš„æ—¶å€™å°±ä¸èƒ½ç”¨å®ƒï¼Œå› ä¸ºéœ€è¦ä¸ææ„æ“ä½œåŒæ­¥

### memory_order_acquire, memory_order_release, memory_order_acq_rel

- memory_order_acquire, memory_order_release, memory_order_acq_relèƒ½å®ç°synchronizes-withçš„å…³ç³»ï¼šå¦‚æœä¸€ä¸ªacquireæ“ä½œåœ¨è¯¥åŸå­å¯¹è±¡ä¸Šè¯»åˆ°ä¸€ä¸ªreleaseæ“ä½œå†™å…¥çš„å€¼ï¼Œåˆ™releaseæ“ä½œsynchronizes-with acquireæ“ä½œ
    - loadæ“ä½œä½¿ç”¨memory_order_acquire
    - storeæ“ä½œä½¿ç”¨memory_order_release
    - Read-Modify-Writeæ“ä½œä½¿ç”¨memory_order_acquireæ—¶è¡¨ç¤ºloadæ“ä½œï¼Œä½¿ç”¨memory_order_releaseæ—¶è¡¨ç¤ºstoreæ“ä½œï¼Œä½¿ç”¨memory_order_acq_relå…¼å…·ä¸¤è€…
- å†æ¥çœ‹ä¸ªä¾‹å­ï¼šæ˜¾ç„¶æ“ä½œ2 synchronizes-withæ“ä½œ3ï¼Œæ‰€ä»¥æ“ä½œ1 happens-beforeæ“ä½œ4ï¼Œæ–­è¨€æ°¸è¿œä¸ä¼šå¤±è´¥ï¼Œå³ä½¿xä½¿ç”¨çš„æ˜¯memory_order_relaxed

```c++
#include <iostream>
#include <atomic>
#include <thread>
#include <assert.h>

using namespace std;

atomic<bool> x(false), y(false);

void threadA() {
    x.store(true, memory_order_relaxed);    // 1
    y.store(true, memory_order_release);    // 2
}

void threadB() {
    while(!y.load(memory_order_acquire));   // 3
    assert(x.load(memory_order_relaxed));  // 4
}

int main() {
    thread tA(threadA), tB(threadB);

    tA.join();
    tB.join();

    return 0;
}
```

- æ³¨æ„ï¼šmemory_order_acquireå’Œmemory_order_releaseä¸€å®šæ˜¯æˆå¯¹ä½¿ç”¨çš„ï¼Œä»–ä¿©éƒ½ä¸èƒ½å’Œmemory_order_relaxedç»„é˜Ÿå®ç°synchronizes-withçš„å…³ç³»
- è®©æˆ‘ä»¬å†ä½¿ç”¨é¡ºåºä¸€è‡´æ€§çš„é‚£ä¸ªä¾‹å­å·©å›ºä¸€ä¸‹acquire/releaseï¼šè¿™æ¬¡å°±ä¸èƒ½ä¿è¯7å¤„çš„æ–­è¨€ä¸€å®šä¸å¤±è´¥ï¼Œå› ä¸ºåœ¨åŒä¸€è½®è¿è¡Œä¸­ï¼ŒtCå¯èƒ½çœ‹åˆ°å…ˆ1å2ï¼ŒtDå´å¯èƒ½çœ‹åˆ°å…ˆ2å1ï¼Œä¸ä¿è¯å…¨å±€ä¸€è‡´æ€§ï¼Œè¿™æ ·å°±å¯èƒ½å¯¼è‡´4å’Œ6çš„load()ç»“æœéƒ½æ˜¯falseï¼Œæœ€ç»ˆå¯¼è‡´zè¿˜æ˜¯0

```c++
#include <iostream>
#include <atomic>
#include <thread>
#include <assert.h>

using namespace std;

atomic<bool> x(false), y(false);
atomic<int> z(0);

void threadA() {
    x.store(true, memory_order_release);    // 1
}

void threadB() {
    y.store(true, memory_order_release);    // 2
}

void x_then_y() {
    while(!x.load(memory_order_acquire));   // 3
    if(y.load(memory_order_acquire)) ++z;   // 4
}

void y_then_x() {
    while(!y.load(memory_order_acquire));   // 5
    if(x.load(memory_order_acquire)) ++z;   // 6
}

int main() {
    thread tA(threadA), tB(threadB), tC(x_then_y), tD(y_then_x);

    tA.join();
    tB.join();
    tC.join();
    tD.join();

    assert(z.load() != 0);  // 7

    return 0;
}
```

## ä¸€è‡´æ€§æ¨¡å‹

> å…³äºä¸€è‡´æ€§æ¨¡å‹çš„å¼•å…¥ï¼Œå€Ÿç”¨Modern CPPä¸­çš„è§£é‡Šï¼šå¹¶è¡Œæ‰§è¡Œçš„å¤šçº¿ç¨‹åœ¨æŸç§ç¨‹åº¦ä¸Šå¯ä»¥çœ‹ä½œåˆ†å¸ƒå¼ç³»ç»Ÿï¼Œåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œä»»ä½•é€šä¿¡ä¹ƒè‡³æœ¬åœ°æ“ä½œéƒ½éœ€è¦æ¶ˆè€—ä¸€å®šçš„æ—¶é—´ï¼Œç”šè‡³å‡ºç°ä¸å¯é çš„é€šä¿¡ï¼Œå‡å¦‚æˆ‘ä»¬å¼ºè¡Œå°†ä¸€ä¸ªå¯¹è±¡xåœ¨å¤šçº¿ç¨‹é—´çš„æ“ä½œè®¾ä¸ºåŸå­æ“ä½œï¼Œä¹Ÿå°±æ˜¯ä»»ä½•ä¸€ä¸ªçº¿ç¨‹åœ¨æ“ä½œå®Œxåï¼Œå…¶ä»–çº¿ç¨‹å‡èƒ½åŒæ­¥æ„ŸçŸ¥åˆ°xçš„å˜åŒ–ï¼Œä½†æ˜¯å¯¹äºxæ¥è¯´ï¼Œå®ƒå¹¶æ²¡æœ‰å› ä¸ºå¼•å…¥å¤šçº¿ç¨‹å¸¦æ¥æ•ˆç‡æå‡ï¼Œé‚£ä¹ˆæœ‰ä»€ä¹ˆåŠæ³•èƒ½æå‡æ•ˆç‡å‘¢ï¼Ÿäºæ˜¯å°±è¦å‰Šå¼±åŸå­æ“ä½œåœ¨å¤šçº¿ç¨‹é—´çš„åŒæ­¥æ¡ä»¶
{: .prompt-info }

- æœ‰å››ç§ä¸€è‡´æ€§æ¨¡å‹ï¼š
    - çº¿æ€§ä¸€è‡´æ€§ï¼šæœ€å¼ºçš„ä¸€è‡´æ€§ï¼Œè¦æ±‚ä»»ä½•ä¸€æ¬¡è¯»æ“ä½œéƒ½èƒ½è¯»åˆ°è¿™ä¸ªæ•°æ®çš„æœ€è¿‘ä¸€æ¬¡å†™å…¥çš„æ•°æ®ï¼Œä¸”æ‰€æœ‰çº¿ç¨‹çš„æ“ä½œé¡ºåºä¸å…¨å±€æ—¶é’Ÿä¸‹çš„é¡ºåºæ˜¯ä¸€è‡´çš„ï¼Œå¾ˆéš¾å®ç°
    - é¡ºåºä¸€è‡´æ€§ï¼šä¸è¦æ±‚ä¸å…¨å±€æ—¶é’Ÿçš„é¡ºåºä¸€è‡´ï¼Œä½†åŒæ ·è¦æ±‚ä»»ä½•ä¸€æ¬¡è¯»æ“ä½œéƒ½èƒ½è¯»åˆ°è¿™ä¸ªæ•°æ®çš„æœ€è¿‘ä¸€æ¬¡å†™å…¥çš„æ•°æ®
    - å› æœä¸€è‡´æ€§ï¼šåªè¦æ±‚æœ‰å› æœå…³ç³»çš„æ“ä½œé¡ºåºå¾—åˆ°ä¿éšœï¼Œæ²¡æœ‰å› æœå…³ç³»çš„æ“ä½œé¡ºåºä¸åšè¦æ±‚
    - æœ€ç»ˆä¸€è‡´æ€§ï¼šæœ€å¼±çš„ä¸€è‡´æ€§ï¼Œåªè¦æ±‚æ“ä½œæ˜¯åŸå­çš„ï¼Œåœ¨æœªæ¥çš„æŸä¸ªæ—¶é—´ç‚¹ä¸Šä¼šè¢«è§‚æµ‹åˆ°æ›´æ”¹åçš„ç»“æœ

```
// çº¿æ€§ä¸€è‡´æ€§
        x.store(1)      x.load()
T1 ---------+----------------+------>

T2 -------------------+------------->
                x.store(2)

// x.store(1)ä¸¥æ ¼å‘ç”Ÿåœ¨x.store(2)å‰ï¼Œx.store(2)ä¸¥æ ¼å‘ç”Ÿåœ¨x.load()å‰
```

```
// é¡ºåºä¸€è‡´æ€§
        x.store(1)  x.store(3)   x.load()
T1 ---------+-----------+----------+----->

T2 ---------------+---------------------->
              x.store(2)
æˆ–è€…
        x.store(1)  x.store(3)   x.load()
T1 ---------+-----------+----------+----->

T2 ------+------------------------------->
      x.store(2)

// x.load()å¿…é¡»è¯»åˆ°æœ€è¿‘ä¸€æ¬¡å†™å…¥çš„æ•°æ®ï¼Œx.store(2)ä¸x.store(1)å¹¶æ— å¼ºåˆ¶å…ˆåï¼Œä½†x.store(2)å¿…é¡»åœ¨x.store(3)å‰å‘ç”Ÿ
```

```
// å› æœä¸€è‡´æ€§
      a = 1      b = 2
T1 ----+-----------+---------------------------->

T2 ------+--------------------+--------+-------->
      x.store(3)         c = a + b    y.load()
æˆ–è€…
      a = 1      b = 2
T1 ----+-----------+---------------------------->

T2 ------+--------------------+--------+-------->
      x.store(3)          y.load()   c = a + b
äº¦æˆ–è€…
     b = 2       a = 1
T1 ----+-----------+---------------------------->

T2 ------+--------------------+--------+-------->
      y.load()            c = a + b  x.store(3)

// æ•´ä¸ªè¿‡ç¨‹åªæœ‰cå¯¹a, bäº§ç”Ÿä¾èµ–ï¼Œå› æ­¤x,yåœ¨ä½•æ—¶æ“ä½œå‡å¯ï¼Œåªè¦ä¿è¯c = a + båœ¨ç¡®å®ša, båå‘ç”Ÿå³å¯
```
    
```
// æœ€ç»ˆä¸€è‡´æ€§
    x.store(3)  x.store(4)
T1 ----+-----------+-------------------------------------------->

T2 ---------+------------+--------------------+--------+-------->
         x.read()      x.read()           x.read()   x.read()

// å‡è®¾xçš„åˆå§‹å€¼ä¸º0,é‚£ä¹ˆT2çš„å››æ¬¡è¯»å–å°±å¯èƒ½æœ‰å¦‚ä¸‹ç»“æœ
3 4 4 4 // x çš„å†™æ“ä½œè¢«å¾ˆå¿«è§‚å¯Ÿåˆ°
0 3 3 4 // x çš„å†™æ“ä½œè¢«è§‚å¯Ÿåˆ°çš„æ—¶é—´å­˜åœ¨ä¸€å®šå»¶è¿Ÿ
0 0 0 4 // æœ€åä¸€æ¬¡è¯»æ“ä½œè¯»åˆ°äº† x çš„æœ€ç»ˆå€¼ï¼Œä½†æ­¤å‰çš„å˜åŒ–å¹¶æœªè§‚å¯Ÿåˆ°
0 0 0 0 // åœ¨å½“å‰æ—¶é—´æ®µå†… x çš„å†™æ“ä½œå‡æœªè¢«è§‚å¯Ÿåˆ°ï¼Œ
        // ä½†æœªæ¥æŸä¸ªæ—¶é—´ç‚¹ä¸Šä¸€å®šèƒ½è§‚å¯Ÿåˆ° x ä¸º 4 çš„æƒ…å†µ
```


## å¸¸ç”¨æˆå‘˜å‡½æ•°

| API | è¯´æ˜ |
| --- | --- |
|`store()`|åŸå­åœ°å°†éåŸå­å¯¹è±¡å†™å…¥åŸå­å¯¹è±¡ï¼Œç¬¬äºŒå‚æ•°ä¸ºå†…å­˜åº|
|`load()`|åŸå­åœ°ä»åŸå­å¯¹è±¡è¯»å–å†…ç½®çš„å¯¹è±¡ï¼Œç¬¬äºŒå‚æ•°ä¸ºå†…å­˜åº|
|`is_lock_free()`|åˆ¤æ–­åŸå­å¯¹è±¡çš„æ“ä½œæ˜¯å¦æ— é”(æ˜¯å¦å¯ä»¥ç”¨CPUæŒ‡ä»¤ç›´æ¥å®ŒæˆåŸå­æ“ä½œ)|
|`exchange()`|åŸå­åœ°æ›¿æ¢åŸå­å¯¹è±¡çš„å€¼å¹¶è·å–å®ƒå…ˆå‰çš„å€¼, Read-Modify-Writeæ“ä½œï¼Œç¬¬äºŒå‚æ•°ä¸ºå†…å­˜åº|
|`compare_exchange_weak()` <br> `compare_exchange_striong()`|CompareAndSwapï¼ŒRead-Modify-Writeæ“ä½œï¼Œå¯ä»¥åˆ†åˆ«æŒ‡å®šæˆåŠŸå’Œå¤±è´¥æ—¶çš„å†…å­˜åºï¼Œä¹Ÿå¯ä»¥åªæŒ‡å®šä¸€ä¸ªï¼Œæˆ–è€…ä½¿ç”¨é»˜è®¤çš„å†…å­˜åº|
|`wait()`(C++20)|é˜»å¡çº¿ç¨‹ç›´è‡³è¢«é€šçŸ¥åŸå­å€¼æ”¹å˜|
|`notify_one()` <br> `notify_all()`(C++20)|é€šçŸ¥åœ¨åŸå­å¯¹è±¡ä¸Šé˜»å¡ç­‰å¾…çš„çº¿ç¨‹|
|`fetch_add()` <br> `fetch_sub()`|åªå¯¹æ•´æ•°å’ŒæŒ‡é’ˆå†…ç½®å¯¹è±¡æœ‰æ•ˆï¼Œå¯¹åŸå­å¯¹è±¡æ‰§è¡Œ+/-æ“ä½œï¼Œè¿”å›åŸå§‹å€¼ï¼ŒRead-Modify-Writeæ“ä½œï¼Œç¬¬äºŒå‚æ•°ä¸ºå†…å­˜åº|
|`++` <br> `--`(å‰ç½®andåç½®)|åªå¯¹æ•´æ•°å’ŒæŒ‡é’ˆå†…ç½®å¯¹è±¡æœ‰æ•ˆï¼Œå¯¹åŸå­å¯¹è±¡æ‰§è¡Œ+1/-1æ“ä½œï¼ŒRead-Modify-Writeæ“ä½œï¼Œä½¿ç”¨é¡ºåºä¸€æ‰§æ€§è¯­ä¹‰|
|`+=` <br> `-=`(å‰ç½®andåç½®)|åªå¯¹æ•´æ•°å’ŒæŒ‡é’ˆå†…ç½®å¯¹è±¡æœ‰æ•ˆï¼Œå¯¹åŸå­å¯¹è±¡æ‰§è¡Œ+/-æ“ä½œï¼Œè¿”å›æ“ä½œåçš„æ•°å€¼ï¼ŒRead-Modify-Writeæ“ä½œï¼Œä½¿ç”¨é¡ºåºä¸€æ‰§æ€§è¯­ä¹‰|
|`fetch_and()` <br> `fetch_or()` <br> `fetch_xor()`|åªå¯¹å¸ƒå°”å†…ç½®å¯¹è±¡æœ‰æ•ˆï¼Œå¯¹åŸå­å¯¹è±¡æ‰§è¡Œä¸/æˆ–/å¼‚æˆ–æ“ä½œï¼Œè¿”å›åŸå§‹å€¼ï¼ŒRead-Modify-Writeæ“ä½œï¼Œç¬¬äºŒå‚æ•°ä¸ºå†…å­˜åº|
|`&=` <br> `|=` <br> `^=`|åªå¯¹å¸ƒå°”å†…ç½®å¯¹è±¡æœ‰æ•ˆï¼Œå¯¹åŸå­å¯¹è±¡æ‰§è¡Œä¸/æˆ–/å¼‚æˆ–æ“ä½œï¼Œè¿”å›æ“ä½œåçš„å€¼ï¼ŒRead-Modify-Writeæ“ä½œï¼Œä½¿ç”¨é¡ºåºä¸€æ‰§æ€§è¯­ä¹‰|

---

# åº”ç”¨

## è‡ªæ—‹é”

- è‡ªæ—‹é”é€‚ç”¨äºä¸´ç•ŒåŒºæ‰§è¡Œæ—¶é—´çŸ­çš„åœºæ™¯ï¼Œç›¸æ¯”äºä¸€èˆ¬çš„äº’æ–¥é”ï¼Œèƒ½å‡å°‘çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢å¸¦æ¥çš„å¼€é”€
- è‡ªæ—‹é”éœ€è¦ä¿è¯åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è·å–åˆ°é”ï¼Œä¸”åŠ é”åï¼Œè¢«ä¿æŠ¤çš„æ•°æ®æ€»æ˜¯æœ€æ–°çš„ï¼Œä¹Ÿå°±æ˜¯éœ€è¦ä¿è¯çº¿ç¨‹åŒæ­¥
- çœ‹ä¸‹é¢çš„ä»£ç ï¼šçº¿ç¨‹Aå¾€deqä¸­æ·»åŠ æ•°æ®ï¼Œpush_back()è¿™ä¸€æ¡æ“ä½œçš„èƒŒåå°±éšå«ç€valçš„å¤åˆ¶ã€deqè¿­ä»£å™¨çš„ç§»åŠ¨ï¼Œä¹Ÿè®¸è¿˜ä¼šresizeé˜Ÿåˆ—ï¼Œæ‰€ä»¥å¾—å¯¹è¿™ä¸€ç³»åˆ—æ“ä½œåŠ é”ï¼Œä½†æ˜¯æ•´ä¸ªæ“ä½œåˆä¸æ˜¯å¾ˆè€—æ—¶ï¼Œæ²¡æœ‰å¿…è¦åˆ‡æ¢çº¿ç¨‹ï¼Œæ‰€ä»¥å°±é‡‡ç”¨è‡ªæ—‹é”ï¼Œè€Œä¸”æˆ‘ä»¬éœ€è¦ä¿è¯çº¿ç¨‹Aè·å–åˆ°mtxæ—¶ï¼Œå¯¹å…¶ä»–çº¿ç¨‹æ˜¯å¯è§çš„ï¼Œå½“ç„¶çº¿ç¨‹Bçš„å‡ºé˜Ÿä¹ŸåŒç†ï¼Œæ‰€ä»¥**è‡ªæ—‹é”éœ€è¦ä¿è¯unlockæ“ä½œ synchronizes-with lockæ“ä½œ**

```c++
deque<int> deq;
spinlock mtx;

void threadA() {
    int val;
    while(val = read_from_remote) {
        mtx.lock();         // 1
        deq.push_back(val); // 2
        mtx.unlock();       // 3
    }
}

void threadB() {
    while(true) {
        mtx.lock();         // 4
        cout << deq.front() << endl;
        deq.pop_front();    // 5
        mtx.unlock();       // 6
    }
}
```
- spinlockå°±å¯ä»¥ä½¿ç”¨acquire/releaseæ¥å®ç°synchronizes-withå…³ç³»ï¼Œ**é”è¢«å ç”¨æ—¶ä¸ºflagä¸ºtrue**ï¼š
    - åŠ é”æ—¶ï¼šflagåˆå§‹å€¼æ˜¯falseï¼ŒåŠ é”åè¿›å…¥lock()å‡½æ•°æ‰§è¡Œæ“ä½œ7ï¼Œflagè¢«ç½®ä¸ºtrueåŒæ—¶è¿”å›falseï¼Œé€€å‡ºå¾ªç¯å®ŒæˆåŠ é”ï¼Œæ­¤æ—¶è‹¥æœ‰å…¶ä»–çº¿ç¨‹æ¥æŠ¢å é”ï¼Œ7å¤„çš„exchange()ä¼šä¸€ç›´è¿”å›trueï¼Œè¯¥çº¿ç¨‹å°±ä¼šé˜»å¡åœ¨å¾ªç¯ä¸­
    - è§£é”æ—¶ï¼šflagè¢«ç½®ä¸ºfalseï¼Œé˜»å¡åœ¨7çš„çº¿ç¨‹ä¼šæŠŠflagé‡æ–°ç½®trueæŠ¢å é”ï¼Œä½†è¿”å›falseé€€å‡ºå¾ªç¯ï¼Œå†æ¬¡åŠ é”æˆåŠŸ
    - æ˜¾ç„¶ï¼Œ8 synchronizes-with 7ï¼Œæ‰€ä»¥unlock() synchronizes-with lock()ï¼Œæ€»èƒ½ä¿è¯ä¸Šä¸€æ¬¡çš„è§£é”ä¸è¿™ä¸€æ¬¡çš„åŠ é”synchronizes-with

```c++
class spinlock {
private:
    atomic<bool> flag(false);
public:
    void lock() {
        while(flag.exchange(true, memory_order_acquire));   // 7
    }
    void unlock() {
        flag.store(false, memory_order_release); // 8
    }
};
```

## çº¿ç¨‹å®‰å…¨çš„Singleton

- Singletonæ˜¯ä¸€ä¸ªéå¸¸æ³¨é‡æ€§èƒ½çš„è®¾è®¡æ¨¡å¼ï¼Œå®ƒé€‚ç”¨äºåœ¨ç³»ç»Ÿä¸­åªå­˜åœ¨ä¸€ä»½å®ä¾‹çš„ç‰¹æ®Šç±»
- å¸¸è§„çš„æ–¹æ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªé™æ€æˆå‘˜æŒ‡é’ˆå­˜å‚¨è¯¥classçš„å”¯ä¸€å®ä¾‹ï¼Œå†ç”¨é™æ€æˆå‘˜å‡½æ•°è·å–ï¼Œä½†è¿™å¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„

```c++
#include <atomic>
#include <mutex>

class Singleton {
private:
    // æŠŠctor, copy-ctoræ”¾åœ¨private
    Singleton();
    Singleton(const Singleton& other);
public:
    static Singleton* m_instance;   // é™æ€æˆå‘˜æŒ‡é’ˆå­˜å‚¨ç±»çš„å”¯ä¸€å®ä¾‹
    static Singleton* getInstance();    // é™æ€æˆå‘˜å‡½æ•°è·å–é™æ€æˆå‘˜æŒ‡é’ˆ
};

Singleton* Singleton::m_instance = nullptr;

// éçº¿ç¨‹å®‰å…¨ç‰ˆæœ¬ï¼šå‡è®¾threadAå’ŒthreadBåŒæ—¶è¿›å…¥if()ï¼Œæ²¡æ³•ä¿è¯ç¬¬20è¡Œåªæ‰§è¡Œä¸€æ¬¡
Singleton* Singleton::getInstance() {
    // æœªåˆ›å»ºè¿‡å®ä¾‹å°±åˆ›å»ºï¼Œå¦åˆ™ç›´æ¥è¿”å›
    if(m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}
```

- **åŠ é”**ï¼šä½†ä»£ä»·è¿‡é«˜ï¼Œå› ä¸ºåªæœ‰åœ¨åˆå§‹åˆ›å»ºæ—¶æ‰ä¼šæœ‰å¹¶å‘é—®é¢˜, åç»­åªéœ€è¦è¿”å›æŒ‡é’ˆå³å¯, æ‰€ä»¥æ— é¡»ç»™æ•´ä¸ªå‡½æ•°åŠ é”
- **åŒæ£€æŸ¥é”**: é”å‰é”ååŒæ£€æŸ¥, m_instanceä¸ºç©ºæ‰åŠ é”ï¼Œå¦åˆ™ç›´æ¥è¿”å›, åŠ é”åå†æ¬¡åˆ¤æ–­æ˜¯å¦ä¸ºç©ºï¼Œé¿å…22åˆ¤æ–­å&&è·å–é”ä¹‹å‰, æœ‰å…¶ä»–çº¿ç¨‹åˆ›å»ºäº†å¯¹è±¡ï¼Œä½†æ˜¯è¿™ç§åšæ³•ä¹Ÿå­˜åœ¨é—®é¢˜
    - 22è¡Œå¹¶æ²¡æœ‰åœ¨é”çš„ä¿æŠ¤ä¸‹ï¼Œå®ƒå°±æœ‰å¯èƒ½ä¸25è¡Œå¹¶å‘ï¼Œå¯¼è‡´data race
    - åŒæ£€æŸ¥é”ç”±äºå†…å­˜è¯»å†™reorderä¹Ÿä¼šå¯¼è‡´ä¸å®‰å…¨: å½“æˆ‘ä»¬ä½¿ç”¨ç¬¬25è¡Œåˆ›å»ºå¯¹è±¡æ—¶ï¼Œæˆ‘ä»¬é»˜è®¤CPUæŒ‡ä»¤çš„æ‰§è¡Œé€»è¾‘æ˜¯å…ˆå¼€è¾Ÿå†…å­˜ï¼Œå†è°ƒç”¨å¯¹è±¡çš„ctorï¼Œæœ€åè¿”å›å†…å­˜åœ°å€ç»™m_instanceï¼Œä½†å®é™…ä¸Šï¼ŒCPUå¾ˆå¯èƒ½ä¼šå…ˆå¼€è¾Ÿå†…å­˜ï¼Œå†è¿”å›å†…å­˜åœ°å€ç»™m_instanceï¼Œæœ€åè°ƒç”¨å¯¹è±¡ctorï¼Œæ­¤å³reorderï¼Œå¯¹æŒ‡ä»¤çš„é‡æ’åºï¼Œreorderåè¿”å›å†…å­˜åœ°å€ç»™m_instance, å®ƒä¸æ˜¯nullptr, threadAè¿˜åœ¨æ‰§è¡Œç¬¬22è¡Œ, threadBå°±ä¼šç›´æ¥è¿”å›m_instance, ä½†æ˜¯å¯¹è±¡çš„ctorè¿˜æ²¡æœ‰è°ƒç”¨ï¼Œæ˜¯ä¸å®Œæ•´çš„å¯¹è±¡åˆ›å»ºï¼Œerror

```c++
class Singleton {
private:
    Singleton();
    Singleton(const Singleton& other);
public:
    static Singleton* m_instance;
    static std::mutex m_mutex;
    static Singleton* getInstance();
};

// çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬: åŠ é”(å…¨å‡½æ•°ç‰ˆ)
Singleton* Singleton::getInstance() {
    std::lock_guard<std::mutex> lck(m_mutex);
    if(m_instance == nullptr) {
        m_instance = new Singleton();
    }
    return m_instance;
}

// åŒæ£€æŸ¥é”ç‰ˆæœ¬
Singleton* Singleton::getInstance() {
    if(m_instance == nullptr) {
        std::lock_guard<std::mutex> lck(m_mutex);
        if(m_instance == nullptr) {
            m_instance = new Singleton();
        }
    }
    return m_instance;
}
```

- å†…å­˜æ …æ atomic_thread_fence + memory_order_relaxedç‰ˆæœ¬

```c++
class Singleton {
private:
    Singleton();
    Singleton(const Singleton& other);
public:
    static std::atomic<Singleton*> m_instance;  // åŸå­å¯¹è±¡
    static std::mutex m_mutex;
    static Singleton* getInstance();
};

// ä½¿ç”¨atomic_thread_fence, å®½æ¾æ¨¡å‹å³å¯
Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance.load(std::memory_order_relaxed);
    std::atomic_thread_fence(std::memory_order_acquire);    // è·å–å†…å­˜fence
    if(tmp == nullptr) {
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if(tmp == nullptr) {
            tmp = new Singleton();
            std::atomic_thread_fence(std::memory_order_release);    // é‡Šæ”¾å†…å­˜fence
            m_instance.store(tmp, std::memory_order_relaxed);
        }
    }
    return m_instance;
}
```

- ä½†å¸¸ç”¨çš„å…¶å®æ˜¯acquire/releaseç‰ˆæœ¬ï¼š12è¡Œ synchronizes-with 18è¡Œï¼Œ15ä½¿ç”¨memory_order_relaxedæ˜¯å› ä¸ºå®ƒåœ¨é”çš„ä¿æŠ¤ä¸‹ï¼Œèƒ½ä¿è¯çº¿ç¨‹åŒæ­¥

```c++
class Singleton {
private:
    Singleton();
    Singleton(const Singleton& other);
public:
    static std::atomic<Singleton*> m_instance;  // åŸå­å¯¹è±¡
    static std::mutex m_mutex;
    static Singleton* getInstance();
};

Singleton* Singleton::getInstance() {
    Singleton* tmp = m_instance.load(std::memory_order_acquire);
    if(tmp == nullptr) {
        std::lock_guard<std::mutex> lock(m_mutex);
        tmp = m_instance.load(std::memory_order_relaxed);
        if(tmp == nullptr) {
            tmp = new Singleton();
            m_instance.store(tmp, std::memory_order_release);
        }
    }
    return m_instance;
}
```

## å¹¶å‘é˜Ÿåˆ—çš„æ¥å£

> è¿™ä¸ªä¾‹å­æ¥è‡ªå´è€å¸ˆï¼Œå¹¶å‘ä¼šç»™STLçš„æ¥å£å¸¦æ¥å†²å‡»
{: .prompt-info }

- å›é¡¾`std::queue<T>`çš„æ¥å£ï¼Œå¦‚æœæˆ‘ä»¬æ­£é€šè¿‡`front()`è®¿é—®é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä½†ä¸æ­¤åŒæ—¶å®ƒè¢«å¦ä¸€ä¸ªçº¿ç¨‹`pop()`äº†ï¼Œæ€ä¹ˆåŠï¼Ÿå¹¶å‘å®‰å…¨çš„æ¥å£å¤§æ¦‚é•¿ä¸‹é¢è¿™æ ·
```c++
template <typename T>
class queue {
public:
    void wait_and_pop(T& dest);
    bool try_pop(T& dest);
};
```
- åˆ©ç”¨åŸå­é‡å®ç°çš„æ— é”ä¸”é«˜æ•ˆç‰ˆå¹¶å‘é˜Ÿåˆ—ï¼Œæ˜¯ä¸ªéå¸¸å¤æ‚çš„è¯é¢˜ï¼Œä¹‹åå•å¼€è®°å½•ï¼Œè®©æˆ‘ä»¬å…ˆmarkä¸€ä¸‹å´è€å¸ˆçš„æ¨èé˜…è¯»
    - [å•ç”Ÿäº§è€…ã€å•æ¶ˆè´¹è€…çš„æ— é”å¹¶å‘å®šé•¿ç¯å½¢é˜Ÿåˆ—](https://github.com/adah1972/nvwa)
    - [å¤šç”Ÿäº§è€…ã€å¤šæ¶ˆè´¹è€…çš„æ— é”é€šç”¨å¹¶å‘é˜Ÿåˆ—](https://github.com/cameron314/concurrentqueue)
    - [æ— é”é˜Ÿåˆ—](https://coolshell.cn/articles/8239.html)

---

# reference
- [cppreference](https://en.cppreference.com/w/cpp/thread)
- [ç°ä»£C++æ•™ç¨‹ï¼šé«˜é€Ÿä¸Šæ‰‹C++11/14/17/20](https://changkun.de/modern-cpp/)
- å´å’ç‚œï¼šæå®¢æ—¶é—´ã€Šç°ä»£C++ç¼–ç¨‹å®æˆ˜ã€‹
- C++ Concurrency in action